코테 - 패스만한다는 마인드, 기본적 알고리즘, 데이터스트럭쳐
파이썬을 가장 추천 - 표준라이브러리 갖다쓰면 됨, 특히 문자열, 실행속도 느리다고 하지만 코테에서는 관계 x 
하지만 면접에서는 복잡한 알고리즘도 물어보니까 공부해야됨

프로그래머스, leetcode

시간복잡도 - 문제가 주어지면 바로 풀이하기 전에 시간복잡도를 생각해봐야함,  
	       big-0에 데이터의 최대 크기(n)를 넣은 값이 1억이 넘으면 시간 제한 초과 가능성. 
	       n이 10000일때, 완전탐색 시 n*n이면 1억이 넘으니까 이건 안된다 , 
	       그렇다면  정렬을하면 nlogn이니까 더 빨리 풀 수 있나?
	       시간복잡도가 n이라면 메모리를 사용함으로써 (by using hashMap) 한번씩만 순회하며 기록하자..  이런식으로 단계적으로 생각
공간복잡도는 한국에서 크게 상관 x 

brute force - 가장 naive한 방식. 
=> 정렬을 하고 나면 더 효과적으로 처리할 수 있는 경우가 이음

링크드 리스트 : 각자 언어에서 어떻게 구현되는지 알아두면 좋음 (그래프나 트리에서 이용되기 때문)

큐 

스택 - 단독으로도 많이 출제되니까, 이런 문제는 스택으로 푸는거구나하는 지식이 필요. 조건을 만족하면 꺼내고 아니면 킵해두는 로직이 필요할 때 사용 

해시 테이블 - 코테나 면접이나 굉장히 중요한개념 , 면접에서는 해시 펑션의 종류 (중복 제거할 수 있는)를 물어볼 수 있음 , collision, separate chaining등은 면접에서 자주 나옴 / 검색이나 저장 모두 O(1)로 수행할 수 있으므로 굉장히 효율적 

------------------------------------------------------------------------
day 2

재귀 - recurrence relation + base case

dp - 관계를 파악한 후 쪼개서 재귀
        1. 내가 풀고자 하는 problem이 중복되는(반복되는) subproblem들로 나뉘어 질 때. 즉 재귀의 조건과 유사하다.
        2. optimal substructure를 갖는 문제일 때. 즉, 최적의 솔루션을 찾는 과정이 중복되는 subproblem의 최적의 솔루션을 찾는 과정으로 부터 얻어질 때.

dp의 중복 제거, 시간복잡도 향상 방법론 
- Memoization(top-down) - 재귀 이용,  생각해내기 쉽지만 중복이 다수 발생 => 결과값을 저장함으로써 문제를 해결 (해시맵처럼), 이후 해당 값이 올때 메모리에서 값을 꺼내오면서 불필요한 재귀 방지 -> o(n)으로 시간복잡도 효율성 증대

-tabulation(bottom-up) - 반복문 사용,  base case부터 올라가는 거. 런타임이 Memoization보다 빠른 편 (사실 코테 수준에서는 유의미한 차이는  x) 

DP문제들은 다음과 같은 특성들이 있다.

DP 문제들은 보통 optimum value(maximum or minimum)를 묻는 경우가 많다.  또는 어떤걸 하는 방법의 갯수를 물어본다.
    - ~ 하는데 드는 최소비용은 얼마인가
    - ~를 통해 얻는 최대 이익은 얼마인가
    - ~ 하는 방법은 몇가지가 있는가
    - ~를 만족하는 가장 긴 문자열 몇글자인가
    - 특정 지점에 도달할 수 있는가?

그래프, DFS, BFS
그래프 - 다익스트라를 제외한다면 거의 다 무방향 그래프
그래프 구현 방법
- 인접리스트 : 메모리는 적게 쓰지만 탐색 시간이 오래 걸림 ; 잘 안쓰게됨 

BFS - 큐
DFS - 스택 or 재귀 

미로찾기 - 최단거리 문제 : BFS


---------------------------------------------
